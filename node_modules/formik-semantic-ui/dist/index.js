'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var formik = require('formik');
var semanticUiReact = require('semantic-ui-react');

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var reactIs_production_min = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports,"__esModule",{value:!0});
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?Symbol.for("react.memo"):
60115,r=b?Symbol.for("react.lazy"):60116;function t(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case h:return a;default:return u}}case r:case q:case d:return u}}}function v(a){return t(a)===m}exports.typeOf=t;exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;
exports.Fragment=e;exports.Lazy=r;exports.Memo=q;exports.Portal=d;exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||"object"===typeof a&&null!==a&&(a.$$typeof===r||a.$$typeof===q||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n)};exports.isAsyncMode=function(a){return v(a)||t(a)===l};exports.isConcurrentMode=v;exports.isContextConsumer=function(a){return t(a)===k};
exports.isContextProvider=function(a){return t(a)===h};exports.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return t(a)===n};exports.isFragment=function(a){return t(a)===e};exports.isLazy=function(a){return t(a)===r};exports.isMemo=function(a){return t(a)===q};exports.isPortal=function(a){return t(a)===d};exports.isProfiler=function(a){return t(a)===g};exports.isStrictMode=function(a){return t(a)===f};
exports.isSuspense=function(a){return t(a)===p};
});

unwrapExports(reactIs_production_min);
var reactIs_production_min_1 = reactIs_production_min.typeOf;
var reactIs_production_min_2 = reactIs_production_min.AsyncMode;
var reactIs_production_min_3 = reactIs_production_min.ConcurrentMode;
var reactIs_production_min_4 = reactIs_production_min.ContextConsumer;
var reactIs_production_min_5 = reactIs_production_min.ContextProvider;
var reactIs_production_min_6 = reactIs_production_min.Element;
var reactIs_production_min_7 = reactIs_production_min.ForwardRef;
var reactIs_production_min_8 = reactIs_production_min.Fragment;
var reactIs_production_min_9 = reactIs_production_min.Lazy;
var reactIs_production_min_10 = reactIs_production_min.Memo;
var reactIs_production_min_11 = reactIs_production_min.Portal;
var reactIs_production_min_12 = reactIs_production_min.Profiler;
var reactIs_production_min_13 = reactIs_production_min.StrictMode;
var reactIs_production_min_14 = reactIs_production_min.Suspense;
var reactIs_production_min_15 = reactIs_production_min.isValidElementType;
var reactIs_production_min_16 = reactIs_production_min.isAsyncMode;
var reactIs_production_min_17 = reactIs_production_min.isConcurrentMode;
var reactIs_production_min_18 = reactIs_production_min.isContextConsumer;
var reactIs_production_min_19 = reactIs_production_min.isContextProvider;
var reactIs_production_min_20 = reactIs_production_min.isElement;
var reactIs_production_min_21 = reactIs_production_min.isForwardRef;
var reactIs_production_min_22 = reactIs_production_min.isFragment;
var reactIs_production_min_23 = reactIs_production_min.isLazy;
var reactIs_production_min_24 = reactIs_production_min.isMemo;
var reactIs_production_min_25 = reactIs_production_min.isPortal;
var reactIs_production_min_26 = reactIs_production_min.isProfiler;
var reactIs_production_min_27 = reactIs_production_min.isStrictMode;
var reactIs_production_min_28 = reactIs_production_min.isSuspense;

var reactIs_development = createCommonjsModule(function (module, exports) {



if (process.env.NODE_ENV !== "production") {
  (function() {

Object.defineProperty(exports, '__esModule', { value: true });

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' ||
  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;
    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;
          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;
              default:
                return $$typeof;
            }
        }
      case REACT_LAZY_TYPE:
      case REACT_MEMO_TYPE:
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
}

// AsyncMode is deprecated along with isAsyncMode
var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;

var hasWarnedAboutDeprecatedIsAsyncMode = false;

// AsyncMode should be deprecated
function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true;
      lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }
  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.typeOf = typeOf;
exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isValidElementType = isValidElementType;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
  })();
}
});

unwrapExports(reactIs_development);
var reactIs_development_1 = reactIs_development.typeOf;
var reactIs_development_2 = reactIs_development.AsyncMode;
var reactIs_development_3 = reactIs_development.ConcurrentMode;
var reactIs_development_4 = reactIs_development.ContextConsumer;
var reactIs_development_5 = reactIs_development.ContextProvider;
var reactIs_development_6 = reactIs_development.Element;
var reactIs_development_7 = reactIs_development.ForwardRef;
var reactIs_development_8 = reactIs_development.Fragment;
var reactIs_development_9 = reactIs_development.Lazy;
var reactIs_development_10 = reactIs_development.Memo;
var reactIs_development_11 = reactIs_development.Portal;
var reactIs_development_12 = reactIs_development.Profiler;
var reactIs_development_13 = reactIs_development.StrictMode;
var reactIs_development_14 = reactIs_development.Suspense;
var reactIs_development_15 = reactIs_development.isValidElementType;
var reactIs_development_16 = reactIs_development.isAsyncMode;
var reactIs_development_17 = reactIs_development.isConcurrentMode;
var reactIs_development_18 = reactIs_development.isContextConsumer;
var reactIs_development_19 = reactIs_development.isContextProvider;
var reactIs_development_20 = reactIs_development.isElement;
var reactIs_development_21 = reactIs_development.isForwardRef;
var reactIs_development_22 = reactIs_development.isFragment;
var reactIs_development_23 = reactIs_development.isLazy;
var reactIs_development_24 = reactIs_development.isMemo;
var reactIs_development_25 = reactIs_development.isPortal;
var reactIs_development_26 = reactIs_development.isProfiler;
var reactIs_development_27 = reactIs_development.isStrictMode;
var reactIs_development_28 = reactIs_development.isSuspense;

var reactIs = createCommonjsModule(function (module) {

if (process.env.NODE_ENV === 'production') {
  module.exports = reactIs_production_min;
} else {
  module.exports = reactIs_development;
}
});

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var FORWARD_REF_STATICS = {
    '$$typeof': true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
};

var MEMO_STATICS = {
    '$$typeof': true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
};

var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;

function getStatics(component) {
    if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
    }
    return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
}

var hoistNonReactStatics_cjs = hoistNonReactStatics;

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty$1 = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Button = hoistNonReactStatics_cjs(function (props) {
  return React__default.createElement(semanticUiReact.Button, _extends({}, props, { type: 'button' }));
}, semanticUiReact.Button);

Button.Submit = function (props) {
  return React__default.createElement(semanticUiReact.Button, _extends({ primary: true }, props, { type: 'submit' }));
};

Button.Reset = formik.connect(function (_ref) {
  var handleReset = _ref.formik.handleReset,
      props = objectWithoutProperties(_ref, ['formik']);
  return React__default.createElement(semanticUiReact.Button, _extends({ basic: true }, props, { type: 'button', onClick: handleReset }));
});

var ErrorMessage = function ErrorMessage(_ref) {
  var message = _ref.message;
  return React__default.createElement(
    "span",
    { className: "sui-error-message" },
    message
  );
};

var getFieldError = function getFieldError(field, form) {
  var name = field.name;

  var _ref = form.status || {},
      serverValidation = _ref.serverValidation;

  var touched = formik.getIn(form.touched, name);
  var checkTouched = serverValidation ? !touched : touched;
  return checkTouched && formik.getIn(form.errors, name);
};

var setFieldValue = function setFieldValue(form, name, value, shouldValidate) {
  form.setFieldValue(name, value, shouldValidate);
  form.setFieldTouched(name, true, shouldValidate);
};

var FormikDropdown = function (_Component) {
  inherits(FormikDropdown, _Component);

  function FormikDropdown(props) {
    classCallCheck(this, FormikDropdown);

    var _this = possibleConstructorReturn(this, (FormikDropdown.__proto__ || Object.getPrototypeOf(FormikDropdown)).call(this, props));

    var id = props.id,
        name = props.name;

    _this.id = id || 'field_dropdown_' + name;
    return _this;
  }

  createClass(FormikDropdown, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          name = _props.name,
          label = _props.label,
          options = _props.options,
          validate = _props.validate,
          _props$inputProps = _props.inputProps,
          inputProps = _props$inputProps === undefined ? {} : _props$inputProps,
          _props$fieldProps = _props.fieldProps,
          fieldProps = _props$fieldProps === undefined ? {} : _props$fieldProps,
          _props$errorComponent = _props.errorComponent,
          errorComponent = _props$errorComponent === undefined ? ErrorMessage : _props$errorComponent,
          fast = _props.fast;
      var _onChange = inputProps.onChange,
          safeInputProps = objectWithoutProperties(inputProps, ['onChange']);

      var DesiredField = fast === true ? formik.FastField : formik.Field;
      return React__default.createElement(DesiredField, {
        name: name,
        validate: validate,
        render: function render(_ref) {
          var field = _ref.field,
              form = _ref.form;

          var error = getFieldError(field, form);
          return React__default.createElement(
            semanticUiReact.Form.Field,
            _extends({ error: !!error }, fieldProps),
            !!label && React__default.createElement(
              'label',
              { htmlFor: _this2.id, onClick: function onClick() {
                  return _this2._dropdown.open();
                } },
              label
            ),
            React__default.createElement(semanticUiReact.Dropdown, _extends({
              ref: function ref(el) {
                return _this2._dropdown = el;
              },
              id: _this2.id,
              name: name,
              options: options,
              selectOnBlur: false,
              selectOnNavigation: false,
              selection: true
            }, safeInputProps, {
              value: field.value,
              onChange: function onChange(e, _ref2) {
                var name = _ref2.name,
                    value = _ref2.value;

                setFieldValue(form, name, value, true);
                Promise.resolve().then(function () {
                  _onChange && _onChange(e, { name: name, value: value });
                });
              }
            })),
            error && React__default.createElement(errorComponent, { message: formik.getIn(form.errors, name) })
          );
        }
      });
    }
  }]);
  return FormikDropdown;
}(React.Component);

var findInput = function findInput(cb, el) {
  return el && cb(el.querySelector('input'));
};

var NullRef = function NullRef(_ref) {
  var children = _ref.children;
  return React__default.createElement(
    React.Fragment,
    null,
    children
  );
};

var InputRef = function InputRef(_ref2) {
  var inputRef = _ref2.inputRef,
      children = _ref2.children;

  var RefWrapper = inputRef ? semanticUiReact.Ref : NullRef;
  return React__default.createElement(
    RefWrapper,
    { innerRef: function innerRef(el) {
        return findInput(inputRef, el);
      } },
    children
  );
};

var FormikTextArea = function (_Component) {
  inherits(FormikTextArea, _Component);

  function FormikTextArea(props) {
    classCallCheck(this, FormikTextArea);

    var _this = possibleConstructorReturn(this, (FormikTextArea.__proto__ || Object.getPrototypeOf(FormikTextArea)).call(this, props));

    var id = props.id,
        name = props.name;

    _this.id = id || 'field_textarea_' + name;
    return _this;
  }

  createClass(FormikTextArea, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          name = _props.name,
          label = _props.label,
          validate = _props.validate,
          _props$inputProps = _props.inputProps,
          inputProps = _props$inputProps === undefined ? {} : _props$inputProps,
          _props$fieldProps = _props.fieldProps,
          fieldProps = _props$fieldProps === undefined ? {} : _props$fieldProps,
          _props$errorComponent = _props.errorComponent,
          errorComponent = _props$errorComponent === undefined ? ErrorMessage : _props$errorComponent,
          inputRef = _props.inputRef,
          fast = _props.fast;
      var _onChange = inputProps.onChange,
          safeInputProps = objectWithoutProperties(inputProps, ['onChange']);

      var RefWrapper = inputRef ? semanticUiReact.Ref : NullRef;
      var DesiredField = fast === true ? formik.FastField : formik.Field;
      return React__default.createElement(DesiredField, {
        name: name,
        validate: validate,
        render: function render(_ref) {
          var field = _ref.field,
              form = _ref.form;

          var error = getFieldError(field, form);
          return React__default.createElement(
            semanticUiReact.Form.Field,
            _extends({ error: !!error }, fieldProps),
            !!label && React__default.createElement(
              'label',
              { htmlFor: _this2.id },
              label
            ),
            React__default.createElement(
              RefWrapper,
              { innerRef: inputRef },
              React__default.createElement(semanticUiReact.TextArea, _extends({
                id: _this2.id,
                name: name,
                rows: 4
              }, safeInputProps, {
                value: field.value,
                onChange: function onChange(e, _ref2) {
                  var name = _ref2.name,
                      value = _ref2.value;

                  setFieldValue(form, name, value, false);
                  Promise.resolve().then(function () {
                    _onChange && _onChange(e, { name: name, value: value });
                  });
                },
                onBlur: form.handleBlur
              }))
            ),
            error && React__default.createElement(errorComponent, { message: formik.getIn(form.errors, name) })
          );
        }
      });
    }
  }]);
  return FormikTextArea;
}(React.Component);

var FormikCheckbox = function (_Component) {
  inherits(FormikCheckbox, _Component);

  function FormikCheckbox(props) {
    classCallCheck(this, FormikCheckbox);

    var _this = possibleConstructorReturn(this, (FormikCheckbox.__proto__ || Object.getPrototypeOf(FormikCheckbox)).call(this, props));

    var id = props.id,
        name = props.name;

    _this.id = id || 'field_checkbox_' + name;
    return _this;
  }

  createClass(FormikCheckbox, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          name = _props.name,
          label = _props.label,
          validate = _props.validate,
          _props$inputProps = _props.inputProps,
          inputProps = _props$inputProps === undefined ? {} : _props$inputProps,
          _props$fieldProps = _props.fieldProps,
          fieldProps = _props$fieldProps === undefined ? {} : _props$fieldProps,
          _props$errorComponent = _props.errorComponent,
          errorComponent = _props$errorComponent === undefined ? ErrorMessage : _props$errorComponent,
          inputRef = _props.inputRef,
          fast = _props.fast;
      var _onChange = inputProps.onChange,
          safeInputProps = objectWithoutProperties(inputProps, ['onChange']);

      var DesiredField = fast === true ? formik.FastField : formik.Field;
      return React__default.createElement(DesiredField, {
        name: name,
        validate: validate,
        render: function render(_ref) {
          var field = _ref.field,
              form = _ref.form;

          var error = getFieldError(field, form);
          return React__default.createElement(
            semanticUiReact.Form.Field,
            _extends({ error: !!error }, fieldProps),
            React__default.createElement(
              InputRef,
              { inputRef: inputRef },
              React__default.createElement(semanticUiReact.Checkbox, _extends({}, safeInputProps, {
                id: _this2.id,
                label: label,
                name: name,
                checked: field.value,
                onChange: function onChange(e, _ref2) {
                  var name = _ref2.name,
                      checked = _ref2.checked;

                  setFieldValue(form, name, checked, true);
                  Promise.resolve().then(function () {
                    _onChange && _onChange(e, { name: name, value: checked });
                  });
                }
              }))
            ),
            error && React__default.createElement(errorComponent, { message: formik.getIn(form.errors, name) })
          );
        }
      });
    }
  }]);
  return FormikCheckbox;
}(React.Component);

var FormikInput = function (_Component) {
  inherits(FormikInput, _Component);

  function FormikInput(props) {
    classCallCheck(this, FormikInput);

    var _this = possibleConstructorReturn(this, (FormikInput.__proto__ || Object.getPrototypeOf(FormikInput)).call(this, props));

    var id = props.id,
        name = props.name;

    _this.id = id || 'field_input_' + name;
    return _this;
  }

  createClass(FormikInput, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          name = _props.name,
          label = _props.label,
          validate = _props.validate,
          _props$inputProps = _props.inputProps,
          inputProps = _props$inputProps === undefined ? {} : _props$inputProps,
          _props$fieldProps = _props.fieldProps,
          fieldProps = _props$fieldProps === undefined ? {} : _props$fieldProps,
          _props$errorComponent = _props.errorComponent,
          errorComponent = _props$errorComponent === undefined ? ErrorMessage : _props$errorComponent,
          inputRef = _props.inputRef,
          fast = _props.fast;
      var _onChange = inputProps.onChange,
          safeInputProps = objectWithoutProperties(inputProps, ['onChange']);

      var DesiredField = fast === true ? formik.FastField : formik.Field;

      return React__default.createElement(DesiredField, {
        name: name,
        validate: validate,
        render: function render(_ref) {
          var field = _ref.field,
              form = _ref.form;

          var error = getFieldError(field, form);

          return React__default.createElement(
            semanticUiReact.Form.Field,
            _extends({ error: !!error }, fieldProps),
            !!label && React__default.createElement(
              'label',
              { htmlFor: _this2.id },
              label
            ),
            React__default.createElement(
              InputRef,
              { inputRef: inputRef },
              React__default.createElement(semanticUiReact.Input, _extends({
                id: _this2.id,
                name: name
              }, safeInputProps, {
                value: field.value,
                onChange: function onChange(e, _ref2) {
                  var name = _ref2.name,
                      value = _ref2.value;

                  setFieldValue(form, name, value, false);
                  Promise.resolve().then(function () {
                    _onChange && _onChange(e, { name: name, value: value });
                  });
                },
                onBlur: form.handleBlur
              }))
            ),
            error && React__default.createElement(errorComponent, { message: formik.getIn(form.errors, name) })
          );
        }
      });
    }
  }]);
  return FormikInput;
}(React.Component);

var componentFactory = function componentFactory(schema) {
  if (!schema) {
    return undefined;
  }

  var typeMap = {
    input: FormikInput,
    dropdown: FormikDropdown,
    textarea: FormikTextArea,
    checkbox: FormikCheckbox
  };

  return Object.keys(schema).map(function (name) {
    var property = schema[name];
    var Component = typeMap[property.type] || typeMap.input;
    var type = property.type,
        value = property.value,
        props = objectWithoutProperties(property, ['type', 'value']);

    if (Component === FormikInput) {
      props.inputProps = props.inputProps || {};
      props.inputProps.type = type;
    }
    return React__default.createElement(Component, _extends({ key: name, name: name }, props));
  });
};

var FormikForm = function (_React$Component) {
  inherits(FormikForm, _React$Component);

  function FormikForm() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, FormikForm);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FormikForm.__proto__ || Object.getPrototypeOf(FormikForm)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      schemaComponents: componentFactory(_this.props.schema)
    }, _this._validate = function (values) {
      return new Promise(function (resolve, reject) {
        var mappedValidation = Object.keys(_this._errors).reduce(function (acc, key) {
          if (!_this._touched[key] && _this._errors[key]) {
            acc[key] = _this._errors[key];
          }
          return acc;
        }, {});
        if (Object.keys(mappedValidation).length) {
          reject(mappedValidation);
        } else {
          resolve();
        }
      });
    }, _this._onSubmit = function (values, formikApi) {
      var result = _this.props.onSubmit(values, formikApi);
      var touched = Object.keys(values).reduce(function (acc, key) {
        return _extends({}, acc, defineProperty$1({}, key, false));
      }, {});
      if (result && result.then) {
        result.then(function () {
          if (_this._mounted) {
            formikApi.setTouched(touched);
          }
        });
      } else {
        if (_this._mounted) {
          formikApi.setTouched(touched);
        }
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(FormikForm, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._mounted = true;
      if (this.props.serverValidation) {
        this._setStatus({ serverValidation: true });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._mounted = false;
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          className = _props.className,
          inverted = _props.inverted,
          size = _props.size,
          ignoreLoading = _props.ignoreLoading,
          children = _props.children,
          render = _props.render,
          component = _props.component,
          _props$initialValues = _props.initialValues,
          initialValues = _props$initialValues === undefined ? {} : _props$initialValues,
          formikProps = objectWithoutProperties(_props, ['className', 'inverted', 'size', 'ignoreLoading', 'children', 'render', 'component', 'initialValues']);


      var testid = formikProps['data-testid'];
      var serverValidation = formikProps.serverValidation;

      var formProps = {
        className: className,
        inverted: inverted,
        size: size
      };

      if (testid) {
        formProps['data-testid'] = testid;
      }

      if (component) {
        console.error('\n        The formik component prop is not supported in this wrapper.\n        Import the Formik control from the formik package to use this scenario.\n        ');
        throw new Error('Unsupported prop');
      }

      var _props$schema = this.props.schema,
          schema = _props$schema === undefined ? {} : _props$schema;


      var mappedValues = Object.keys(schema || initialValues || {}).reduce(function (acc, key) {
        var property = schema[key] || {};
        acc[key] = property.value || initialValues[key] || (property.type === 'checkbox' ? false : '');
        return acc;
      }, initialValues);

      var serverProps = serverValidation ? {
        validate: this._validate,
        onSubmit: this._onSubmit
      } : {};

      return React__default.createElement(
        formik.Formik,
        _extends({
          validateOnChange: false
        }, _extends({
          initialValues: mappedValues
        }, formikProps, serverProps)),
        function (renderProps) {
          var handleSubmit = renderProps.handleSubmit,
              isSubmitting = renderProps.isSubmitting,
              errors = renderProps.errors,
              touched = renderProps.touched,
              setFieldError = renderProps.setFieldError,
              setStatus = renderProps.setStatus,
              setErrors = renderProps.setErrors;

          _this2._errors = errors;
          _this2._touched = touched;
          _this2._setFieldError = setFieldError;
          _this2._setStatus = setStatus;
          return React__default.createElement(
            semanticUiReact.Form,
            _extends({}, formProps, {
              onSubmit: function onSubmit(e) {
                if (serverValidation) {
                  e.persist();
                  setErrors({});
                  Promise.resolve().then(function () {
                    handleSubmit(e);
                  });
                } else {
                  handleSubmit(e);
                }
              },
              loading: isSubmitting && !ignoreLoading
            }),
            _this2.state.schemaComponents,
            typeof children === 'function' || typeof render === 'function' ? (render || children)(renderProps) : children
          );
        }
      );
    }
  }]);
  return FormikForm;
}(React__default.Component);

FormikForm.defaultProps = {
  validate: function validate(values) {
    return {};
  }
};


var Form = hoistNonReactStatics_cjs(FormikForm, semanticUiReact.Form);
Form.Children = React__default.Fragment;

var FormikCheckbox$1 = function (_Component) {
  inherits(FormikCheckbox, _Component);

  function FormikCheckbox(props) {
    classCallCheck(this, FormikCheckbox);

    var _this = possibleConstructorReturn(this, (FormikCheckbox.__proto__ || Object.getPrototypeOf(FormikCheckbox)).call(this, props));

    var id = props.id,
        name = props.name,
        value = props.value;

    _this.id = id ? id + '_' + value : 'field_radio_' + name + '_' + value;
    return _this;
  }

  createClass(FormikCheckbox, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          name = _props.name,
          label = _props.label,
          value = _props.value,
          validate = _props.validate,
          _props$inputProps = _props.inputProps,
          inputProps = _props$inputProps === undefined ? {} : _props$inputProps,
          _props$fieldProps = _props.fieldProps,
          fieldProps = _props$fieldProps === undefined ? {} : _props$fieldProps,
          _props$errorComponent = _props.errorComponent,
          errorComponent = _props$errorComponent === undefined ? ErrorMessage : _props$errorComponent,
          inputRef = _props.inputRef,
          fast = _props.fast;
      var _onChange = inputProps.onChange,
          safeInputProps = objectWithoutProperties(inputProps, ['onChange']);

      var DesiredField = fast === true ? formik.FastField : formik.Field;
      return React__default.createElement(DesiredField, {
        name: name,
        validate: validate,
        render: function render(_ref) {
          var field = _ref.field,
              form = _ref.form;

          var error = getFieldError(field, form);
          return React__default.createElement(
            semanticUiReact.Form.Field,
            _extends({ error: !!error }, fieldProps),
            React__default.createElement(
              InputRef,
              { inputRef: inputRef },
              React__default.createElement(semanticUiReact.Radio, _extends({}, safeInputProps, {
                id: _this2.id,
                label: label,
                name: name,
                value: value,
                checked: field.value === value,
                onChange: function onChange(e, _ref2) {
                  var name = _ref2.name,
                      value = _ref2.value;

                  setFieldValue(form, name, value, true);
                  Promise.resolve().then(function () {
                    _onChange && _onChange(e, { name: name, value: value });
                  });
                }
              }))
            ),
            error && React__default.createElement(errorComponent, { message: formik.getIn(form.errors, name) })
          );
        }
      });
    }
  }]);
  return FormikCheckbox;
}(React.Component);

// export { default as DatePicker } from "./DatePicker";
// export { default as FileUpload } from "./FileUpload";

exports.Button = Button;
exports.Form = Form;
exports.Input = FormikInput;
exports.Checkbox = FormikCheckbox;
exports.Radio = FormikCheckbox$1;
exports.Dropdown = FormikDropdown;
exports.TextArea = FormikTextArea;
//# sourceMappingURL=index.js.map
