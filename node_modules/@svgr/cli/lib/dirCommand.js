"use strict";

exports.__esModule = true;
exports.isCompilable = isCompilable;
exports.default = dirCommand;

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

var _chalk = _interopRequireDefault(require("chalk"));

var _core = require("@svgr/core");

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-underscore-dangle, no-console */
async function exists(file) {
  try {
    await _fs.promises.access(file);
    return true;
  } catch (error) {
    return false;
  }
}

function rename(relative, ext, filenameCase) {
  const relativePath = _path.default.parse(relative);

  relativePath.ext = `.${ext}`;
  relativePath.base = null;
  relativePath.name = (0, _util.transformFilename)(relativePath.name, filenameCase);
  return _path.default.format(relativePath);
}

const COMPILABLE_EXTENSIONS = ['.svg', '.SVG'];

function isCompilable(filename) {
  const ext = _path.default.extname(filename);

  return COMPILABLE_EXTENSIONS.includes(ext);
}

function defaultIndexTemplate(filePaths) {
  const exportEntries = filePaths.map(filePath => {
    const basename = _path.default.basename(filePath, _path.default.extname(filePath));

    const exportName = (0, _util.formatExportName)(basename);
    return `export { default as ${exportName} } from './${basename}'`;
  });
  return exportEntries.join('\n');
}

function getDefaultExtension(options) {
  return options.typescript ? 'tsx' : 'js';
}

async function dirCommand(program, filenames, {
  ext,
  filenameCase = _util.CASE.PASCAL,
  ...options
}) {
  async function write(src, dest) {
    if (!isCompilable(src)) return {
      transformed: false,
      dest: null
    };
    ext = ext || getDefaultExtension(options);
    dest = rename(dest, ext, filenameCase);
    const code = await (0, _util.convertFile)(src, options);

    const cwdRelative = _path.default.relative(process.cwd(), dest);

    const logOutput = `${src} -> ${cwdRelative}\n`;

    if (program.ignoreExisting && (await exists(dest))) {
      (0, _util.politeWrite)(program, _chalk.default.grey(logOutput));
      return {
        transformed: false,
        dest
      };
    }

    await _fs.promises.mkdir(_path.default.dirname(dest), {
      recursive: true
    });
    await _fs.promises.writeFile(dest, code);
    (0, _util.politeWrite)(program, _chalk.default.white(logOutput));
    return {
      transformed: true,
      dest
    };
  }

  async function generateIndex(dest, files) {
    const indexFile = _path.default.join(dest, `index.${ext}`);

    const config = _core.loadConfig.sync(options, {
      filePath: indexFile
    });

    const indexTemplate = config.indexTemplate || defaultIndexTemplate;
    await _fs.promises.writeFile(indexFile, indexTemplate(files));
  }

  async function handle(filename, root) {
    const stats = await _fs.promises.stat(filename);

    if (stats.isDirectory()) {
      const dirname = filename;
      const files = await _fs.promises.readdir(dirname);
      const results = await Promise.all(files.map(async relativeFile => {
        const absFile = _path.default.join(dirname, relativeFile);

        return handle(absFile, root);
      }));
      const transformed = results.filter(result => result.transformed);

      if (transformed.length) {
        const destFiles = results.map(result => result.dest).filter(Boolean);

        const dest = _path.default.resolve(program.outDir, _path.default.relative(root, dirname));

        await generateIndex(dest, destFiles);
      }

      return {
        transformed: false,
        dest: null
      };
    }

    const dest = _path.default.resolve(program.outDir, _path.default.relative(root, filename));

    return write(filename, dest);
  }

  await Promise.all(filenames.map(async file => {
    const stats = await _fs.promises.stat(file);
    const root = stats.isDirectory() ? file : _path.default.dirname(file);
    await handle(file, root);
  }));
}